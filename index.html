<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>FPS with Spherical Gravity</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 2px solid white;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="crosshair"></div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.157.0/examples/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    
    // Game variables
    const players = new Map();
    let myId = null;
    let planetRadius = 100;
    let ws = null;
    let controls = null;
    let camera = null;
    let scene = null;
    let renderer = null;
    let lastServerState = null;
    let previousServerState = null;
    let keys = { w: false, a: false, s: false, d: false, ' ': false };
    
    // Initialize the game
    function init() {
      // Set up THREE.js scene
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 0);
      scene.add(directionalLight);
      
      // Create planet (sphere)
      const planetGeometry = new THREE.SphereGeometry(planetRadius, 32, 32);
      const planetMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x5555ff,
        roughness: 0.8,
        metalness: 0.2
      });
      const planet = new THREE.Mesh(planetGeometry, planetMaterial);
      scene.add(planet);
      
      // Set up camera controls
      controls = new PointerLockControls(camera, document.body);
      
      document.addEventListener('click', () => {
        controls.lock();
      });
      
      controls.addEventListener('lock', () => {
        console.log('Controls locked');
      });
      
      controls.addEventListener('unlock', () => {
        console.log('Controls unlocked');
      });
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Handle keyboard input
      window.addEventListener('keydown', (e) => {
        if (keys.hasOwnProperty(e.key.toLowerCase())) {
          keys[e.key.toLowerCase()] = true;
        }
      });
      
      window.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.key.toLowerCase())) {
          keys[e.key.toLowerCase()] = false;
        }
      });
      
      // Connect to WebSocket server
      connectToServer();
      
      // Start game loop
      animate();
    }
    
    // Connect to WebSocket server
    function connectToServer() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}`;
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        console.log('Connected to server');
      };
      
      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        if (message.type === 'init') {
          myId = message.data.id;
          planetRadius = message.data.planetRadius;
          console.log('Initialized with ID:', myId);
        } 
        else if (message.type === 'state') {
          previousServerState = lastServerState;
          lastServerState = message.data;
          
          // Update other players' positions
          const seenIds = new Set();
          
          for (const playerData of message.data.players) {
            seenIds.add(playerData.id);
            
            if (playerData.id === myId) {
              // This is our player
              continue;
            }
            
            if (!players.has(playerData.id)) {
              // Create new player model
              const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
              const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
              const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
              scene.add(playerMesh);
              
              players.set(playerData.id, {
                mesh: playerMesh,
                pos: playerData.pos,
                rot: playerData.rot
              });
            }
            
            // Update player data
            const player = players.get(playerData.id);
            player.targetPos = playerData.pos;
            player.targetRot = playerData.rot;
          }
          
          // Remove disconnected players
          for (const [id, player] of players.entries()) {
            if (!seenIds.has(id)) {
              scene.remove(player.mesh);
              players.delete(id);
            }
          }
        }
      };
      
      ws.onclose = () => {
        console.log('Disconnected from server');
        setTimeout(connectToServer, 3000); // Reconnect after 3 seconds
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
    }
    
    // Send input to server
    function sendInput() {
      if (ws && ws.readyState === WebSocket.OPEN && controls.isLocked) {
        const direction = { x: 0, y: 0, z: 0 };
        
        if (keys.w) direction.z = -1;
        if (keys.s) direction.z = 1;
        if (keys.a) direction.x = -1;
        if (keys.d) direction.x = 1;
        
        // Get camera direction
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        
        // Extract rotation from camera direction
        const rotation = {
          x: Math.asin(cameraDirection.y),
          y: Math.atan2(cameraDirection.x, cameraDirection.z)
        };
        
        ws.send(JSON.stringify({
          type: 'input',
          data: {
            dir: direction,
            rot: rotation,
            timestamp: Date.now()
          }
        }));
      }
    }
    
    // Update camera position based on spherical gravity
    function updateCameraOrientation() {
      if (!lastServerState) return;
      
      // Find our player data
      const playerData = lastServerState.players.find(p => p.id === myId);
      if (!playerData) return;
      
      // Calculate up vector (away from planet center)
      const pos = new THREE.Vector3(
        playerData.pos.x,
        playerData.pos.y,
        playerData.pos.z
      );
      
      const upVector = pos.clone().normalize();
      
      // Position camera at player position
      camera.position.copy(pos);
      
      // Orient camera based on player rotation
      camera.quaternion.setFromEuler(new THREE.Euler(
        playerData.rot.x,
        playerData.rot.y,
        0,
        'YXZ'
      ));
    }
    
    // Lerp between two vectors
    function lerpVectors(a, b, t) {
      return {
        x: a.x + (b.x - a.x) * t,
        y: a.y + (b.y - a.y) * t,
        z: a.z + (b.z - a.z) * t
      };
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Send player input
      sendInput();
      
      // Update camera position/orientation
      updateCameraOrientation();
      
      // Update other players with interpolation
      const now = Date.now();
      
      for (const [id, player] of players.entries()) {
        if (player.targetPos && player.pos) {
          // Simple interpolation
          const t = 0.2; // Adjust for smoothness
          player.pos = lerpVectors(player.pos, player.targetPos, t);
          
          // Update mesh position
          player.mesh.position.set(player.pos.x, player.pos.y, player.pos.z);
          
          // Orient player to stand on sphere surface
          const normalVector = new THREE.Vector3(
            player.pos.x,
            player.pos.y,
            player.pos.z
          ).normalize();
          
          // Look at direction
          const lookVector = new THREE.Vector3();
          lookVector.x = Math.sin(player.targetRot.y) * Math.cos(player.targetRot.x);
          lookVector.y = Math.sin(player.targetRot.x);
          lookVector.z = Math.cos(player.targetRot.y) * Math.cos(player.targetRot.x);
          
          // Create quaternion from up vector (normal) and forward vector
          const quaternion = new THREE.Quaternion();
          const matrix = new THREE.Matrix4().lookAt(
            lookVector,
            new THREE.Vector3(0, 0, 0),
            normalVector
          );
          quaternion.setFromRotationMatrix(matrix);
          
          player.mesh.quaternion.slerp(quaternion, 0.2);
        }
      }
      
      // Render scene
      renderer.render(scene, camera);
    }
    
    // Start the game
    init();
  </script>
</body>
</html>